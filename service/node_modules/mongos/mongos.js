var Mongo = require('mongodb'),
	Db    = Mongo.Db,
	Server = Mongo.Server,
	EventEmitter = require("events").EventEmitter,
	util = require("util");

function Mongos() {

}

function Base() {

}

util.inherits(Base, EventEmitter);

Base._singularize = function() {
	return this.name.toLowerCase();
}

Base._pluralize = function() {
	var name = this._singularize();
	if (name.match(/ch|sh|s$/)) {
		name += "es"
	} else {
		name += "s"
	}
	return name;
}

Base._to_table_name = function() {
	return this._pluralize();
}

Base._to_foreign_key = function() {
	return this._singularize() + "_id";
}


Mongos.superclassof = function(subclass, options) {
	subclass.super_ = Base;
    subclass.prototype = Object.create(Base.prototype, {
	    constructor: {
	      value: subclass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
    });
    for (var class_method in Base) {
    	subclass[class_method] = Base[class_method];
    }

    for (var property in EventEmitter.prototype) {
    	subclass[property] = EventEmitter.prototype[property];
    }

    if (!options) {
    	options = {};
    };
    var host = options["host"] || "127.0.0.1",
    	port = options["port"] || "27017",
    	database = options["database"] || "mongos";


    var match = subclass.toString().match(/table_name\s=\s\"(\w+)\"/),
    	table_name = "";

    if (match) {
    	table_name = match[1];
    };
    subclass.collection_name = subclass.prototype.collection_name = table_name || subclass.table_name ||
    																subclass.prototype.table_name || subclass._to_table_name();


    Base.database = subclass.database = new Db(database, new Server(host, port, {auto_reconnect: true}), {safe: true});
	Base.database.open(function(err,connection) {
		Base.connection = connection;
	})

	subclass.on("first", function(err, docs) {
		if ( ((typeof this._events.first) != "object") && !this.debug_status  ) {
			console.log("Event first is not implemented!");
		};
		if (this.debug_status) {
			if (err) {
				console.log(err);
			} else {
				console.log(docs);
			}
		};
	})
	subclass.on("last", function(err, docs) {
		if ( ((typeof this._events.last) != "object") && !this.debug_status  ) {
			console.log("Event last is not implemented!");
		};
		if (this.debug_status) {
			if (err) {
				console.log(err);
			} else {
				console.log(docs);
			}
		};
	})
	subclass.on("save", function(err, docs) {
		if ( ((typeof this._events.save) != "object") && !this.debug_status  ) {
			console.log("Event save is not implemented!");
		};
		if (this.debug_status) {
			if (err) {
				console.log(err);
			} else {
				console.log(docs);
			}
		};
	})
	subclass.on("insert", function(err, docs) {
		if ( ((typeof this._events.insert) != "object") && !this.debug_status  ) {
			console.log("Event insert is not implemented!");
		};
		if (this.debug_status) {
			if (err) {
				console.log(err);
			} else {
				console.log(docs);
			}
		};
	})
	subclass.on("update", function(err, docs) {
		if ( ((typeof this._events.update) != "object") && !this.debug_status  ) {
			console.log("Event update is not implemented!");
		};
		if (this.debug_status) {
			if (err) {
				console.log(err);
			} else {
				console.log(docs);
			}
		};
	})
	subclass.on("find", function(err, docs) {
		if ( ((typeof this._events.find) != "object") && !this.debug_status  ) {
			console.log("Event find is not implemented!");
		};
		if (this.debug_status) {
			if (err) {
				console.log(err);
			} else {
				console.log(docs);
			}
		};
	})
}

function PresenceValidator(self) {
	var attributes = self.validations["presence"]
	for (var i = attributes.length - 1; i >= 0; i--) {
		if ( !self[attributes[i]] || self[attributes[i]].match(/^\s*$/)  ) {
			self.errors.push(attributes[i] + " can't be blank")
		}
	};
}

function FormatValidator(self) {
	var attributes = self.validations["format"]
	for (var attribute in attributes) {
		if ( !attributes[attribute].test(self[attribute]) ) {
			self.errors.push(attribute + " is not valid")
		}
	};
}


function UniqueValidator(self) {
	var attributes = self.validations["format"]
	for (var i = attributes.length - 1; i >= 0; i--) {
		attributes[i]
	};
}


Base.internal_attributes = function() {
	var _internal_attributes = []
	for (var api_attribute in Base.prototype) {
		_internal_attributes.push(api_attribute);
	}
	for (var i = Base.extra_interal_attributes.length - 1; i >= 0; i--) {
		_internal_attributes.push(Base.extra_interal_attributes[i]);
	};
	return _internal_attributes;
}

Base.extra_interal_attributes = [
									"errors", "validations", "table_name", "_has_many"
								]

Base.prototype.attributes = function() {
	var _attributes = {},
		internals = Base.internal_attributes();
	for (var attribute in this) {
		if (this.hasOwnProperty(attribute) && internals.indexOf(attribute) == -1  ) {
			_attributes[attribute] = this[attribute];
		};
	}
	return _attributes;
}

Base.prototype.reset = function() {
	this.errors = []
}

Base.prototype.save = function(callback) {
	this.reset();

	if (this.validations) {
		for (var validation in this.validations) {
			if (validation == "presence") {
				PresenceValidator(this);
			} else if (validation == "format") {
				FormatValidator(this)
			} else if ( validation == "unique") {
				UniqueValidator(this)
			}
		}
	}

	if (this.errors.length > 0) {
		var err = new Error(this.errors);
		if (callback) {
			callback(err, null);
		} else {
			self.emit("first", err, null);
		}
	} else {
		this.constructor.save(this, callback)
	}

}


Base.save = function(self, callback) {
	if (self["_id"]) {
		Base.update(self, callback);
	} else {
		Base.insert(self, callback);
	}
}

Base.insert = function(self, callback) {
 	if (Base.connection) {
 		Base.connection.collection(self.collection_name).insert(self.attributes(), function(err, docs) {
 			if (err) {
 				if (callback) {
 					callback(err, null);
 				} else {
 					self.emit("insert", err, null);
 				}
 				
 			} else {
 				self.constructor.create(docs, callback, "insert");
 				if (self._has_many) {
 					for (var i = self._has_many.length - 1; i >= 0; i--) {
 						var has_many = self._has_many[i][0],
 							foreign_key = self.constructor._to_foreign_key();
 						self[self._has_many[i][0]][foreign_key] = docs[0]["_id"];
 						for (var j = self[self._has_many[i][0]].length - 1; j >= 0; j--) {
 							self[self._has_many[i][0]][j][foreign_key] = docs[0]["_id"]
 							self[self._has_many[i][0]][j].save();
 						};
 						
 					};
 				};
 			}
 		})
 	};
}

Base.update = function(self, callback) {
	if (Base.connection) {
 		Base.connection.collection(self.collection_name).update({"_id": self["_id"]}, self.attributes(), {safe: true}, function(err, docs) {
 			if (err) {
 				if (callback) {
 					callback(err, null);
 				} else {
 					self.emit("update", err, null);
 				}
 				
 			} else {
 				self.constructor.create(docs, callback, "update");
 				if (self._has_many) {
 					for (var i = self._has_many.length - 1; i >= 0; i--) {
 						var has_many = self._has_many[i][0],
 							foreign_key = self.constructor._to_foreign_key();
 						self[self._has_many[i][0]][foreign_key] = self["_id"];
 						for (var j = self[self._has_many[i][0]].length - 1; j >= 0; j--) {
 							self[self._has_many[i][0]][j][foreign_key] = self["_id"]
 							self[self._has_many[i][0]][j].save();
 						};
 						
 					};
 				};
 			}
 		})
 	};
}

Base.first = function(callback) {
	var self = this;
 	if (Base.connection) {
 		Base.connection.collection(this.collection_name).find().sort({"_id": 1}).limit(1).toArray(function(err, docs) {
 			if (err) {
 				if (callback) {
 					callback(err, null);
 				} else {
 					self.emit("first", err, null);
 				}
 				
 			} else {
 				self.create(docs, callback, "first");
 			}
 		})
 	};
}

Base.last = function(callback) {
	var self = this;
 	if (Base.connection) {
 		Base.connection.collection(this.collection_name).find().sort({"_id": -1}).limit(1).toArray(function(err, docs) {
 			if (err) {
 				if (callback) {
 					callback(err, null);
 				} else {
 					self.emit("last", err, null);
 				}
 				
 			} else {
 				self.create(docs, callback, "last");
 			}
 		})
 	};
}

Base.find = function(options, callback) {
	var self = this;
	if (!options) {
		options = {};
	};
 	if (Base.connection) {
 		Base.connection.collection(self.collection_name).find(options).toArray(function(err, docs) {
 			if (err) {
 				if (callback) {
 					callback(err, null);
 				} else {
 					self.emit("find", err, null);
 				}
 				
 			} else {
 				self.create(docs, callback, "find");
 			}
 		})
 	};
}


Base.create = function(objects, callback, type) {
	var live_objects = [];
	if (objects.length == 0) {
		return live_objects;
	};
	for (var i = objects.length - 1; i >= 0; i--) {
		var object = new this();
		for (var attribute in objects[i]) {
			object[attribute] = objects[i][attribute];
		}
		live_objects.push(object)
	};
	if (callback) {
		callback(null, live_objects);
	} else if (type) {
		this.emit(type, null, live_objects);
	} else {
		return live_objects;
	}
}

Base.debug = function() {
	this.debug_status = !this.debug_status;
}

Base.prototype.has_many = function(method_name, klass) {
	if (this._has_many) {
		this._has_many.push([method_name, klass])
	} else {
		this._has_many = []
		Base.extra_interal_attributes.push(method_name)
		this._has_many.push([method_name, klass])
	}

	this.on(method_name, function(err, docs) {
		if ( ((typeof this._events.first) != "object") && !this.debug_status  ) {
			console.log("Event "+ method_name +" is not implemented!");
		};
		if (this.debug_status) {
			if (err) {
				console.log(err);
			} else {
				console.log(docs);
			}
		};
	})


	this[method_name] = function(callback) {
		var key = this.constructor._to_foreign_key(),

			options = {},
			self = this;

			options[key] = this["_id"];
		klass.find(options, function(err, docs) {
			self[method_name] = docs;
			if (callback) {
				callback(null, docs)
			} else {
				self.emit(method_name, null, docs);
			}
			
		})
	}
}



Mongos.Base = Base;

module.exports = Mongos;
